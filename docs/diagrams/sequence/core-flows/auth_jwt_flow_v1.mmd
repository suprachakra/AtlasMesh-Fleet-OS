---
title: Authentication & Authorization Flow - AtlasMesh Fleet OS
---
sequenceDiagram
    %% HIGH PRIORITY: JWT-based authentication with RBAC/ABAC authorization
    %% Version 1.0 | Generated from: Auth Service traces | Security Level: HIGH
    %% SECURITY: JWT-based authentication with role-based and attribute-based access control
    %% INTEGRATION CONTRACT: OAuth 2.0 + OpenID Connect + JWT tokens
    %% PERFORMANCE: <50ms for token validation, <10ms for policy evaluation
    %% COMPLIANCE: UAE cybersecurity framework + GDPR privacy requirements

    participant OP as üë§ Fleet Operator
    participant UI as üñ•Ô∏è Control Center UI
    participant GW as üö™ API Gateway
    participant AUTH as üîê Auth Service
    participant POL as üìã Policy Engine
    participant VAULT as üîí HashiCorp Vault
    participant DB as üóÑÔ∏è User Database
    participant FM as üöõ Fleet Manager
    participant AUDIT as üìã Audit Service

    %% INITIAL LOGIN
    Note over OP,AUDIT: INITIAL LOGIN
    OP->>UI: Enter credentials<br/>{username, password, MFA}
    Note right of OP: USER: Fleet operator<br/>needs system access

    UI->>UI: Client-side validation<br/>Password strength check
    Note right of UI: UX: Immediate feedback<br/>for invalid inputs

    UI->>GW: POST /api/v1/auth/login<br/>{username, password, mfa_token}
    Note right of UI: SECURITY: HTTPS only<br/>Credentials encrypted in transit

    %% AUTHENTICATION
    Note over OP,AUDIT: AUTHENTICATION
    GW->>AUTH: gRPC: AuthenticateUser<br/>{credentials, client_info}
    Note right of GW: SERVICE: Delegate auth<br/>to specialized service

    AUTH->>DB: Query user account<br/>SELECT * FROM users WHERE username = ?
    Note right of AUTH: DATABASE: Retrieve user<br/>profile and status

    DB-->>AUTH: User profile<br/>{user_id, password_hash, roles, status}

    AUTH->>AUTH: **PASSWORD VERIFICATION**<br/>bcrypt.CompareHashAndPassword<br/>(stored_hash, provided_password)
    Note right of AUTH: SECURITY: bcrypt with<br/>cost factor 12

    alt Invalid credentials
        AUTH-->>GW: ‚ùå Authentication failed<br/>{error: "Invalid credentials"}
        GW-->>UI: HTTP 401: Unauthorized
        UI->>OP: Error: Invalid login
        
        AUTH->>AUDIT: Log failed login<br/>{user, ip, timestamp, reason}
        Note right of AUTH: AUDIT: Security event<br/>logged for monitoring
    else Valid credentials
        AUTH->>AUTH: **MFA VERIFICATION**<br/>TOTP validation<br/>(user_secret, provided_token)
        Note right of AUTH: SECURITY: Time-based OTP<br/>for additional security
        
        alt Invalid MFA
            AUTH-->>GW: ‚ùå MFA verification failed
            GW-->>UI: HTTP 401: MFA required
            UI->>OP: Error: Invalid MFA code
        else Valid MFA
            AUTH->>VAULT: Request signing key<br/>GET /v1/pki/cert/jwt-signing
            Note right of AUTH: SECURITY: RSA private key<br/>for JWT signing
            
            VAULT-->>AUTH: ‚úì Signing key<br/>{private_key, certificate}
            
            AUTH->>AUTH: **GENERATE JWT TOKEN**<br/>Claims: {user_id, roles, permissions}<br/>Algorithm: RS256<br/>Expiration: 1 hour
            Note right of AUTH: JWT: Short-lived token<br/>with user context
            
            AUTH->>AUTH: **GENERATE REFRESH TOKEN**<br/>Secure random token<br/>Expiration: 30 days
            Note right of AUTH: REFRESH: Long-lived token<br/>for token renewal
            
            AUTH->>DB: Store refresh token<br/>INSERT INTO user_sessions<br/>{user_id, refresh_token, expires_at}
            
            AUTH-->>GW: ‚úì Authentication success<br/>{jwt_token, refresh_token, expires_in}
        end
    end

    %% TOKEN RESPONSE
    Note over OP,AUDIT: TOKEN RESPONSE
    GW-->>UI: HTTP 200: Login successful<br/>{access_token, refresh_token, user_profile}
    UI->>UI: Store tokens securely<br/>HttpOnly cookies + localStorage
    Note right of UI: SECURITY: Secure token storage<br/>with XSS protection

    UI->>OP: **LOGIN SUCCESS**<br/>Redirect to dashboard

    %% AUTHORIZED API REQUEST
    Note over OP,AUDIT: AUTHORIZED API REQUEST
    OP->>UI: Click "View Fleet Status"<br/>Request fleet information
    UI->>GW: GET /api/v1/fleets<br/>Authorization: Bearer {jwt_token}
    Note right of UI: API: Include JWT token<br/>in Authorization header

    %% TOKEN VALIDATION
    Note over OP,AUDIT: TOKEN VALIDATION
    GW->>AUTH: gRPC: ValidateToken<br/>{jwt_token, required_permissions}
    Note right of GW: SECURITY: Validate every<br/>API request

    AUTH->>VAULT: Get public key<br/>GET /v1/pki/cert/jwt-verification
    VAULT-->>AUTH: ‚úì Public key<br/>{public_key, certificate}

    AUTH->>AUTH: **JWT VERIFICATION**<br/>- Signature validation (RS256)<br/>- Expiration check<br/>- Issuer validation<br/>- Claims extraction
    Note right of AUTH: SECURITY: Cryptographic<br/>verification of token

    alt Token invalid/expired
        AUTH-->>GW: ‚ùå Token invalid<br/>{error: "Token expired"}
        GW-->>UI: HTTP 401: Unauthorized
        UI->>UI: Attempt token refresh<br/>using refresh_token
        
        alt Refresh successful
            UI->>GW: POST /api/v1/auth/refresh<br/>{refresh_token}
            GW->>AUTH: gRPC: RefreshToken<br/>{refresh_token}
            AUTH->>DB: Validate refresh token<br/>SELECT * FROM user_sessions
            AUTH->>AUTH: Generate new JWT<br/>Same process as login
            AUTH-->>GW: ‚úì New tokens<br/>{jwt_token, refresh_token}
            GW-->>UI: HTTP 200: Tokens refreshed
            UI->>UI: Update stored tokens<br/>Retry original request
        else Refresh failed
            UI->>OP: **SESSION EXPIRED**<br/>Please log in again
        end
    else Token valid
        AUTH-->>GW: ‚úì Token valid<br/>{user_id, roles, permissions}
    end

    %% AUTHORIZATION
    Note over OP,AUDIT: AUTHORIZATION
    GW->>POL: gRPC: EvaluatePolicy<br/>{user_context, resource, action}
    Note right of GW: POLICY: Check if user<br/>can perform requested action

    POL->>POL: **RBAC EVALUATION**<br/>- Check user roles<br/>- Match role permissions<br/>- Resource access rules
    Note right of POL: RBAC: Role-based<br/>access control

    POL->>POL: **ABAC EVALUATION**<br/>- User attributes<br/>- Resource attributes<br/>- Environmental context<br/>- Dynamic policies
    Note right of POL: ABAC: Attribute-based<br/>fine-grained control

    POL->>POL: **OPA/REGO EVALUATION**<br/>allow = true {<br/>  input.user.roles[_] == "fleet_operator"<br/>  input.resource == "fleets"<br/>  input.action == "read"<br/>}
    Note right of POL: POLICY: Declarative<br/>policy evaluation

    alt Access denied
        POL-->>GW: ‚ùå Access denied<br/>{decision: "deny", reason}
        GW-->>UI: HTTP 403: Forbidden
        UI->>OP: Error: Insufficient permissions
        
        POL->>AUDIT: Log access denial<br/>{user, resource, action, reason}
    else Access granted
        POL-->>GW: ‚úì Access granted<br/>{decision: "allow", constraints}
    end

    %% RESOURCE ACCESS
    Note over OP,AUDIT: RESOURCE ACCESS
    GW->>FM: gRPC: GetFleets<br/>{user_context, filters}
    Note right of GW: SERVICE: Forward request<br/>with user context

    FM->>FM: **BUSINESS LOGIC**<br/>- Apply user constraints<br/>- Filter by organization<br/>- Apply data policies
    Note right of FM: BUSINESS: Multi-tenant<br/>data isolation

    FM->>DB: Query fleet data<br/>SELECT * FROM fleets<br/>WHERE organization_id = ?
    DB-->>FM: Fleet data<br/>{fleets[], metadata}

    FM-->>GW: ‚úì Fleet information<br/>{fleets, total_count, permissions}
    GW-->>UI: HTTP 200: Fleet data<br/>{fleets[], user_permissions}

    UI->>OP: **DISPLAY FLEET STATUS**<br/>Fleet dashboard with data

    %% AUDIT & COMPLIANCE
    Note over OP,AUDIT: AUDIT & COMPLIANCE
    AUTH->>AUDIT: Log successful access<br/>{user_id, resource, action, timestamp}
    POL->>AUDIT: Log policy evaluation<br/>{decision, policy_id, context}
    FM->>AUDIT: Log data access<br/>{user_id, data_accessed, filters}

    AUDIT->>AUDIT: **COMPLIANCE LOGGING**<br/>- GDPR access logs<br/>- UAE cybersecurity requirements<br/>- SOX audit trails<br/>- Data lineage tracking
    Note right of AUDIT: COMPLIANCE: Complete<br/>audit trail for regulations

    %% SESSION MANAGEMENT
    Note over OP,AUDIT: SESSION MANAGEMENT
    loop Every 5 minutes
        UI->>GW: GET /api/v1/auth/session<br/>Authorization: Bearer {jwt_token}
        GW->>AUTH: gRPC: ValidateSession<br/>{jwt_token}
        
        alt Token near expiration (<10 min)
            AUTH-->>GW: ‚ö†Ô∏è Token expiring soon
            GW-->>UI: HTTP 200: {expires_soon: true}
            UI->>UI: Auto-refresh token<br/>Seamless user experience
        else Token valid
            AUTH-->>GW: ‚úì Session active
            GW-->>UI: HTTP 200: {session: "active"}
        end
    end

    %% LOGOUT
    Note over OP,AUDIT: LOGOUT
    OP->>UI: Click "Logout"<br/>End session
    UI->>GW: POST /api/v1/auth/logout<br/>Authorization: Bearer {jwt_token}

    GW->>AUTH: gRPC: LogoutUser<br/>{jwt_token, refresh_token}
    AUTH->>DB: Revoke refresh token<br/>DELETE FROM user_sessions<br/>WHERE refresh_token = ?

    AUTH->>AUTH: **TOKEN BLACKLIST**<br/>Add JWT to blacklist<br/>until expiration
    Note right of AUTH: SECURITY: Prevent token<br/>reuse after logout

    AUTH-->>GW: ‚úì Logout successful
    GW-->>UI: HTTP 200: Logged out

    UI->>UI: Clear stored tokens<br/>Redirect to login page
    UI->>OP: **LOGOUT COMPLETE**<br/>Session terminated

    AUTH->>AUDIT: Log logout event<br/>{user_id, session_duration, timestamp}

    %% Styling
    %%{init: {'theme':'base', 'themeVariables': {'primaryColor': '#2c3e50', 'primaryTextColor': '#fff', 'primaryBorderColor': '#34495e', 'lineColor': '#2d3436', 'sectionBkgColor': '#ecf0f1', 'altSectionBkgColor': '#bdc3c7', 'gridColor': '#636e72', 'secondaryColor': '#3498db', 'tertiaryColor': '#e74c3c'}}}%%
